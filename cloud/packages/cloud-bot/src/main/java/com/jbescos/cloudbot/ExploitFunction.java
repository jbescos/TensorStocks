package com.jbescos.cloudbot;

import java.util.Map;
import java.util.logging.Logger;

import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;

import com.google.cloud.functions.HttpFunction;
import com.google.cloud.functions.HttpRequest;
import com.google.cloud.functions.HttpResponse;
import com.jbescos.common.CloudProperties;
import com.jbescos.common.StorageInfo;
import com.jbescos.common.TelegramBot;
import com.jbescos.exchange.PublicAPI;
import com.jbescos.exchange.Utils;

//Entry: com.jbescos.cloudbot.ExploitFunction
public class ExploitFunction implements HttpFunction {

	private static final Logger LOGGER = Logger.getLogger(ExploitFunction.class.getName());
	private static final String USER_ID_PARAM = "userId";

	@Override
	public void service(HttpRequest request, HttpResponse response) throws Exception {
		String userId = Utils.getParam(USER_ID_PARAM, null, request.getQueryParameters());
		if (userId == null || userId.isEmpty()) {
			throw new IllegalArgumentException(USER_ID_PARAM + " query parameter is mandatory");
		}
		StorageInfo storageInfo = StorageInfo.build();
		CloudProperties cloudProperties = new CloudProperties(userId, storageInfo);
		Client client = ClientBuilder.newClient();
		PublicAPI publicAPI = new PublicAPI(client);
		Map<String, Double> binancePrices = Utils.simplePrices(publicAPI.priceBinance());
		// It looks wrong, but sell price is higher than buy
		Map<String, Double> kucoinSellPrices = Utils.simplePrices(publicAPI.priceKucoin());
		Map<String, Double> kucoinBuyPrices = Utils.simplePrices(publicAPI.priceKucoin(ticker -> Double.parseDouble(ticker.getSell())));
		try(TelegramBot telegram = new TelegramBot(cloudProperties, client)) {
			for (String symbol : cloudProperties.BOT_WHITE_LIST_SYMBOLS) {
				Double binanceSellPrice = binancePrices.get(symbol);
				Double binanceBuyPrice = binanceSellPrice;
				Double kucoinSellPrice = kucoinSellPrices.get(symbol);
				Double kucoinBuyPrice = kucoinBuyPrices.get(symbol);
				Boolean trade = null;
				if (benefit(binanceSellPrice, kucoinBuyPrice)) {
					double profit = profitPerUnit(kucoinBuyPrice, binanceSellPrice);
					if (profit > Utils.TRANSFER_MIN_PROFIT_UNIT) {
						if (trade == null) {
							trade = publicAPI.isSymbolEnabled(symbol);
						}
						if (trade) {
							StringBuilder builder = new StringBuilder();
							builder.append("ðŸ’£ ").append(symbol).append(". Big difference of prices between exchanges detected\n");
							builder.append("1. Buy ").append(symbol).append(" in Kucoin. Price: ").append(Utils.format(kucoinBuyPrice)).append(Utils.USDT).append("\n");
							builder.append("2. Transfer every ").append(symbol).append(" to your Binance wallet\n");
							builder.append("3. Sell ").append(symbol).append(" in Binance. Price: ").append(Utils.format(binanceSellPrice)).append(Utils.USDT).append("\n");
							builder.append("Estimated benefit before commissions: ").append(Utils.format(profit)).append(" per unit");
							telegram.sendMessage(builder.toString());
						} else {
							LOGGER.info(symbol + " is in maintenance but there is a profit of " + Utils.format(profit) + " per unit");
						}
					}
				}
				if (benefit(kucoinSellPrice, binanceBuyPrice)) {
					double profit = profitPerUnit(binanceBuyPrice, kucoinSellPrice);
					if (profit > Utils.TRANSFER_MIN_PROFIT_UNIT) {
						if (trade == null) {
							trade = publicAPI.isSymbolEnabled(symbol);
						}
						if (trade) {
							StringBuilder builder = new StringBuilder();
							builder.append("ðŸ’£ ").append(symbol).append(". Big difference of prices between exchanges detected\n");
							builder.append("1. Buy ").append(symbol).append(" in Binance. Price: ").append(Utils.format(binanceBuyPrice)).append(Utils.USDT).append("\n");
							builder.append("2. Transfer every ").append(symbol).append(" to your Kucoin wallet\n");
							builder.append("3. Sell ").append(symbol).append(" in Kucoin. Price: ").append(Utils.format(kucoinSellPrice)).append(Utils.USDT).append("\n");
							builder.append("Estimated benefit before commissions: ").append(Utils.format(profit)).append(" per unit");
							telegram.sendMessage(builder.toString());
						} else {
							LOGGER.info(symbol + " is in maintenance but there is a profit of " + Utils.format(profit) + " per unit");
						}
					}
				}
			}
		}
		client.close();
	}

	private static double profitPerUnit(double low, double high) {
		double diff = high - low;
		return diff / high;
	}

	private static boolean benefit(Double sellPrice, Double buyPrice) {
		if (sellPrice == null || buyPrice == null) {
			return false;
		} else if (sellPrice > buyPrice) {
			return true;
		} else {
			return false;
		}
	}
}
